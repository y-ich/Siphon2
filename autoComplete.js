// Generated by CoffeeScript 1.4.0

/*
# AutoComplete for CodeMirror in CoffeeScript
# (C) 2012 ICHIKAWA, Yuji (New 3 Rs)
*/


(function() {
  var AutoComplete, COFFEE_KEYWORDS, CORE_CLASSES, DATE_PROPERTIES, JS_KEYWORDS, KEYWORDS, KEYWORDS_COMPLETE, OPERATORS, OPERATORS_WITH_EQUAL, UTC_PROPERTIES, classes, e, functions, globalProperties, globalPropertiesPlusKeywords, variables, _i, _len, _ref;

  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super'];

  COFFEE_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when', 'yes', 'no', 'on', 'off'];

  OPERATORS_WITH_EQUAL = ['-', '+', '*', '/', '%', '<', '>', '&', '|', '^', '!', '?', '='];

  OPERATORS = ['->', '=>', 'and', 'or', 'is', 'isnt', 'not', '&&', '||'];

  OPERATORS = OPERATORS.concat(OPERATORS_WITH_EQUAL.concat(OPERATORS_WITH_EQUAL.map(function(e) {
    return e + '=';
  }))).sort();

  UTC_PROPERTIES = ['Date', 'Day', 'FullYear', 'Hours', 'Milliseconds', 'Minutes', 'Month', 'Seconds'];

  DATE_PROPERTIES = ['Time', 'Year'].concat(UTC_PROPERTIES.reduce((function(a, b) {
    return a.concat([b, 'UTC' + b]);
  }), []));

  CORE_CLASSES = {
    Array: ['length', 'concat', 'every', 'filter', 'forEach', 'indexOf', 'join', 'lastIndexOf', 'map', 'pop', 'push', 'reduce', 'reduceRight', 'reverse', 'shift', 'slice', 'some', 'sort', 'splice', 'toLocaleString', 'toString', 'unshift'],
    Boolean: ['toString', 'valueOf'],
    Date: ['getTimezoneOffset', 'toDateString', 'toGMTString', 'toISOString', 'toJSON', 'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString', 'toString', 'toTimeString', 'toUTCString', 'valueOf'].concat(DATE_PROPERTIES.reduce((function(a, b) {
      return a.concat(['get' + b, 'set' + b]);
    }), [])).sort(),
    Error: [],
    EvalError: [],
    Function: [],
    Global: [],
    JSON: [],
    Math: [],
    Number: [],
    Object: [],
    RangeError: [],
    ReferenceError: [],
    RegExp: [],
    String: [],
    SyntaxError: [],
    TypeError: [],
    URIError: []
  };

  KEYWORDS = JS_KEYWORDS.concat(COFFEE_KEYWORDS).sort();

  KEYWORDS_COMPLETE = {
    "if": ['else', 'then else'],
    "for": ['in', 'in when', 'of', 'of when'],
    "try": ['catch finally', 'catch'],
    "class": ['extends'],
    "switch": ['when else', 'when', 'when then else', 'when then']
  };

  globalProperties = (function() {
    var _results;
    _results = [];
    for (e in window) {
      _results.push(e);
    }
    return _results;
  })();

  globalPropertiesPlusKeywords = globalProperties.concat(KEYWORDS).sort();

  variables = [];

  functions = [];

  classes = [];

  _ref = globalProperties.sort();
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    e = _ref[_i];
    if (window[e] === null || (typeof window[e] !== 'function' && /^[A-Z]/.test(e))) {
      continue;
    }
    if (typeof window[e] === 'function') {
      if (/^[A-Z]/.test(e)) {
        classes.push(e);
      } else {
        functions.push(e);
      }
    } else if (!/^[A-Z]/.test(e)) {
      variables.push(e);
    }
  }

  AutoComplete = (function() {

    function AutoComplete(cm, text) {
      this.cm = cm;
      this.char = text.charAt(text.length - 1);
    }

    AutoComplete.prototype.complete = function() {
      var candidates, cursor, key, object, pos, propertyChain, target, token;
      if (this.candidates != null) {
        return;
      }
      this.candidates = [];
      cursor = this.cm.getCursor();
      switch (this.cm.getOption('mode')) {
        case 'coffeescript':
          if (/[a-zA-Z_$\.]/.test(this.char)) {
            propertyChain = [];
            pos = cursor;
            while ((token = this.cm.getTokenAt(pos)).string.charAt(0) === '.') {
              propertyChain.push(token);
              pos = {
                line: cursor.line,
                ch: token.start - 1
              };
            }
            propertyChain.push(token);
            propertyChain.reverse();
            if (propertyChain.length === 1) {
              candidates = globalPropertiesPlusKeywords;
            } else {
              try {
                object = eval(propertyChain.map(function(e) {
                  return e.string;
                }).slice(0, -1).join());
                candidates = (function() {
                  var _results;
                  _results = [];
                  for (key in object) {
                    _results.push(key);
                  }
                  return _results;
                })();
              } catch (err) {
                console.log(err);
                candidates = [];
              }
            }
            target = propertyChain[propertyChain.length - 1].string.replace(/^\./, '');
            this.candidates = candidates.filter(function(e) {
              return new RegExp('^' + target).test(e);
            }).map(function(e) {
              return e.slice(target.length);
            });
          } else if (this.char === ' ') {
            token = this.cm.getTokenAt({
              line: cursor.line,
              ch: cursor.ch - 1
            });
            if (KEYWORDS_COMPLETE.hasOwnProperty(token.string)) {
              this.candidates = KEYWORDS_COMPLETE[token.string];
            }
          }
      }
      if (this.candidates.length > 0) {
        this.index = 0;
        this.cm.replaceRange(this.candidates[this.index], cursor);
        this.start = cursor;
        this.end = this.cm.getCursor();
        return this.cm.setSelection(this.start, this.end);
      }
    };

    AutoComplete.prototype.previous = function() {
      return this.next_(-1);
    };

    AutoComplete.prototype.next = function() {
      return this.next_(1);
    };

    AutoComplete.prototype.next_ = function(increment) {
      var cursor;
      if (this.candidates.length > 1) {
        cursor = this.cm.getCursor();
        this.index += increment;
        if (this.index < 0) {
          this.index = this.candidates.length - 1;
        } else if (this.index >= this.candidates.length) {
          this.index = 0;
        }
        this.cm.replaceRange(this.candidates[this.index], this.start, this.end);
        this.end = this.cm.getCursor();
        return this.cm.setSelection(this.start, this.end);
      }
    };

    return AutoComplete;

  })();

  window.AutoComplete = AutoComplete;

}).call(this);
